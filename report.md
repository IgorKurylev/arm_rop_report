# Возвратно-ориентированное программирование на платформе ARM64

## Краткое введение в ARM64 (Aarch64)

Процессоры с ядрами ARM сейчас достаточно популярны в среде разработчиков мобильных устройств и встраиваемых систем различного применения. Самые массовые из них — это смартфоны (и iOS и Android устройства используют данную архитектуру). Архитектура обладает такими привлекательными свойствами, как удобная и эффективная система команд, мощная поддержка при разработке не только аппаратной базы, но и программного обеспечения, высокая энергоэффективность. Рассмотрим основные особенности системы команд ARM64, которые пригодятся в дальнейшем:

### Регистры

Архитектура имеет 31 регистр общего назначения (X0-X30). Все они 64-битные, но мы можем адресовать младшие 32 бита с помощью префиксов (например w0,w1 и т.д.). Также существует и 32-й регистр XZR, который равен нулю при чтении (можно применять запись в регистр, но результат вычисления не будет никуда записан). В регистр X30 (link register) записывается адрес возврата из подпрограммы.

TODO: SP register

### Инструкции

Перечислю только самые базовые инструкции:
- **mov** аналогично архитектуре x86 копирует значение одного регистра в другой, также может использоваться для загрузки непосредственного значения в регистр
```asm
mov x0, x1; копирует x1 в x0
mov x1, 0x4141; загружает значение 0x4141 в x1
```
- **str/ldr** загрузка в/из регистра соответственно по указателю
```asm
str x0, [x29]; размещает значение x0 по адресу из ОП в x29
ldr x0, [x29]; загружает значение в x0 по адресу из ОП в x29
```
- **bl/blr** эквивалентно **call** в x86 - передает управление на адрес подпрограммы и размещает адрес возврата в X30
```asm
blr x0; вызывает подпрограмму по адресу в x0
```
- **b/br** эквивалентно **jmp** в x86 - безусловный переход по адресу

- **ret** несмотря на **ret** в x86 - здесь не используется стек, а просто управление передается по адресу возврата в X30

### Способы адресации

Используется 3 основных режима:
- Непосредственный: *[base, #offset]*
```asm
ldr x0, [sp, 0x10]; загружается значение в x0 из ОП по адресу sp+0x10
```
- Пре-индексный: *[base, #offset]!*
```asm
ldr x0, [sp, 0x10]!; загружается значение в x0 из ОП по адресу sp+0x10 и затем увеличивается значение sp на 0x10
```
- Пост-индексная: *[base], #offset*
```asm
ldr x0, [sp], 0x10; загружается значение в x0 из ОП по адресу sp и затем увеличивается значение sp на 0x10
```

### Стек и соглашения о вызове функций

- Регистры X0-X7 используются для передачи параметров в подпрограммы, остальные параметры расположены на стеке
- Адрес возврата сохраняется в X30, но в случае вложенных вызовов его значение сохраняется на стеке
- Регистр X29 (frame-pointer) - эквивалент ebp в x86. Все локальные переменные на стеке доступны относительно регистра X29. А в нем самом хранится адрес предыдущего стек-фрейма.  
## Общий обзор возвратно-ориентированного подхода

Метод возвратно-ориентированного программирования (ROP) дает преимущество атакующей стороне в плане возможности подстраивания своего вредоносного кода под различные программные системы. Атакующий анализирует программное обеспечение системы на предмет наличия *гаджетов* - фрагментов кода, выполняющих полезную для атакующего функцию (и чаще всего заканчивающиеся инструкцией **ret**). Например:
```asm
add x0, x1, x2
ret
```
Сканируя библиотеку с кодом интересующей системы, атакующий может собрать много полезных гаджетов, выполняя которые, возможно достичь цели атакующей стороны. Такие гаджеты - реально существующий код на атакуемой системы (обычно в исполняемых секциях shared-библиотек). Это значит, что такой код можно выполнить в обход мер безопасности, предотвращающих исполнение произвольного кода. Атакующий формирует цепочку таких гаджетов, получая таким образом полноценную программу, как показано на рис. .1:
![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/gadgets_chain.png)
Рис. .1 Формирование цепочки гаджетов

Другой похожий метод - Jump-Oriented Programming (JOP). Разница в них заключается в том, что выполняется поиск гаджетов, заканчивающихся на инструкцию **br/blr** (безусловный переход). Данный метод показан на рисунке .2:
![](https://github.com/IgorKurylev/arm_rop_report/blob/master/pics/JOP_chain.png)
Рис.2 Jump-Oriented Programming

Обычно этот способ используется, когда нет доступа к стеку (мы не можем изначально записать в него адреса гаджетов) и в каждом гаджете приходится учитывать адрес следующего в цепочке, что гораздо сложнее реализовать, чем ROP. Но потенциально у JOP больше возможностей, так как команды **br/blr** не ограничены рамками, установленными компилятором или средой исполнения (можно передать любой валидный адрес).
